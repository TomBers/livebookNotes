# Fun with Graphs

## Lets checkout the graphing functionality of LiveBooks

Lets draw some graphs, first setup the graphing tools.

```elixir
Mix.install([
  {:vega_lite, "~> 0.1.0"},
  {:kino, "~> 0.2.0"},
  {:math, "~> 0.6.0"}
])

alias VegaLite, as: Vl
```

Lets generate a parabola

$$ y = x^2$$

```elixir
require Math

data =
  -10..10
  |> Enum.map(fn x -> %{"x" => x, "y" => Math.pow(x, 2)} end)
```

```elixir
Vl.new(width: 400, height: 300)
|> Vl.data_from_values(data)
|> Vl.mark(:point)
|> Vl.encode_field(:x, "x", type: :quantitative)
|> Vl.encode_field(:y, "y", type: :quantitative)
```

Lets try an exponential

$$e^x$$

```elixir
data =
  0..10
  |> Enum.map(fn x -> %{"x" => x, "y" => Math.exp(x)} end)
```

```elixir
Vl.new(width: 400, height: 300)
|> Vl.data_from_values(data)
|> Vl.mark(:line)
|> Vl.encode_field(:x, "x", type: :quantitative)
|> Vl.encode_field(:y, "y", type: :quantitative)
```

Lets try an input - enter a power of x and see how it graphs

<!-- livebook:{"livebook_object":"cell_input","name":"pow","props":{"max":10,"min":1,"step":1},"reactive":true,"type":"range","value":"1"} -->

```elixir
pow = IO.gets("pow") |> String.trim() |> String.to_integer()

IO.inspect("Power: #{pow}")

data =
  -10..10
  |> Enum.map(fn x -> %{"x" => x, "y" => Math.pow(x, pow)} end)

Vl.new(width: 400, height: 300)
|> Vl.data_from_values(data)
|> Vl.mark(:point)
|> Vl.encode_field(:x, "x", type: :quantitative)
|> Vl.encode_field(:y, "y", type: :quantitative)
```

## Plotting multiple lines - towards a Epicycloid

> â€‹If we roll a circle around the circumference of another circle, the shape traced by a point on the moving circle is an epicycloid.

See [Draw Curves with Straight Lines](https://www.mwmresearchgroup.org/draw-curves-with-straight-lines.html)

Lets try drawing multiple lines on the same graph

```elixir
limit = 10

dataA =
  0..limit
  |> Enum.flat_map(fn x ->
    [
      %{"x" => 0, "y" => limit - x, "n" => "lower_#{x}"},
      %{"x" => x, "y" => 0, "n" => "lower_#{x}"}
    ]
  end)

dataB =
  0..limit
  |> Enum.flat_map(fn x ->
    [
      %{"x" => limit, "y" => limit - x, "n" => "upper_#{x}"},
      %{"x" => x, "y" => limit, "n" => "upper_#{x}"}
    ]
  end)

Vl.new(width: 400, height: 300)
|> Vl.data(sequence: [start: 0, stop: 10, step: 1, as: "x"])
|> Vl.data_from_values(dataA ++ dataB)
|> Vl.mark(:line)
|> Vl.encode_field(:x, "x", type: :quantitative)
|> Vl.encode_field(:y, "y", type: :quantitative)
|> Vl.encode_field(:color, "n", type: :nominal)
```

What we want to do now, is to be able to draw a circle with numbers, so that we can draw a line from number 22 to 64 and this will draw a cord across the circle.

As an example, think of a clock, drawing from 3 to 9 would be a horizontal line, where as 11 to 5 would be at an angle.

The challenge to is draw a circle of `n` divisions and map that location to a point on the circle.

Lets try drawing a clock face.

```elixir
defmodule MathHelpers do
  # Split the circle into x divisions - so draw n points around the circumference 
  @number_of_points_to_draw 24
  @radius 200

  def number_of_points_to_draw do
    @number_of_points_to_draw
  end

  def to_radians(0) do
    0
  end

  def to_radians(x) do
    point_to_angle(x) * (Math.pi() / 180)
  end

  def point_to_angle(0) do
    0
  end

  def point_to_angle(x) do
    360 / @number_of_points_to_draw * x
  end

  # See https://stackoverflow.com/questions/839899/how-do-i-calculate-a-point-on-a-circle-s-circumference
  def circle_x(cx, x) do
    cx + @radius * Math.sin(to_radians(x))
  end

  def circle_y(cy, x) do
    cy + @radius * Math.cos(to_radians(x))
  end
end
```

```elixir
w = 400
h = 400
# Center of the circle
cx = w / 2
cy = h / 2

data =
  0..MathHelpers.number_of_points_to_draw()
  |> Enum.map(fn x ->
    %{"x" => MathHelpers.circle_x(cx, x), "y" => MathHelpers.circle_y(cy, x)}
  end)

Vl.new(width: w, height: h)
|> Vl.data_from_values(data)
|> Vl.mark(:point)
|> Vl.encode_field(:x, "x", type: :quantitative)
|> Vl.encode_field(:y, "y", type: :quantitative)
```

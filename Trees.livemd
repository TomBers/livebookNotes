# Trees

## Introduction

[Wikipeida reference](https://en.wikipedia.org/wiki/Binary_search_tree)

We want to build a binary tree, which is a fundamental data structure and one that works quite well as a recursive algorithm.

For this notebook, I want to think about how I would store a tree structure and how you could traverse it both depth first and breadth first.

(These are common tasks typical at university level CS or job interviews)

## The Tree itself

From the Wikipedia entry we see that "In computer science, a binary tree is a tree data structure in which each node has at most two children, which are referred to as the left child and the right child."

It suggests that we can store the tree as "Nodes and references" - binary trees are typically constructed by having a tree node structure which contains some data and references to its left child and its right child.

or

Binary trees can also be stored in breadth-first order as an implicit data structure in arrays, and if the tree is a complete binary tree, this method wastes no space. In this compact arrangement, if a node has an index i, its children are found at indices $${\displaystyle 2i+1}2i+1$$ (for the left child) and $${\displaystyle 2i+2}2i+2$$ (for the right), while its parent (if any) is found at index $${\displaystyle \left\lfloor {\frac {i-1}{2}}\right\rfloor }\left\lfloor {\frac {i-1}{2}}\right\rfloor$$  (assuming the root has index zero). Alternatively, with a 1-indexed array, the implementation is simplified with children found at $${\displaystyle 2i}2i$$ and $${\displaystyle 2i+1}2i+1$$, and parent found at $${\displaystyle \lfloor i/2\rfloor }{\displaystyle \lfloor i/2\rfloor }$$

That is all very complicated, so lets have a go at storing a simple tree

## Experiments

```elixir
# A Tree is a collection of Nodes
defmodule Tree do
  defstruct nodes: []
end
```

```elixir
defmodule Node do
  defstruct val: 0, left_child: nil, right_child: nil, is_root: false
end
```

Lets build a simple tree - ![](images/binary_tree.png)

```elixir
one = %Node{val: 1}
three = %Node{val: 3}
two = %Node{val: 2, left_child: one, right_child: three}

five = %Node{val: 5}
seven = %Node{val: 7}
six = %Node{val: 6, left_child: five, right_child: seven}

four = %Node{val: 4, left_child: two, right_child: six, is_root: true}

tree = %Tree{nodes: four}
```

The challenge now is given this structure can we find a way of going through it and getting the right order out?

```elixir
defmodule TraverseTree do
  def run(tree) do
    tree.nodes
    |> depth_search([], [])
  end

  # We want to go all the way to the bottom of the left hand side adding to a result.
  # We need to keep track of the nodes we visted and add them to the accumulator if they are a leaf (last)
  # or both children have alredy been added

  def depth_search(node, visited, acc) do
    # IO.inspect(node.val)
    # Four actions
    # We find a leaf, add the leaf and return up
    # We find a node, with the left explores - add myself and explore the right hand
    # We find a node with both children unexplored - go down the left first
    # Find a node with both children explored - move up

    if is_leaf(node) do
      {parent, new_visited} = getLastNode(visited)
      depth_search(parent, new_visited, acc ++ [node.val])
    end

    if has_visited_left_child(node, acc) and !has_visited_right_child(node, acc) do
      depth_search(node.right_child, [node] ++ visited, acc ++ [node.val])
    end

    if !has_visited_children(node, acc) do
      depth_search(node.left_child, [node] ++ visited, acc)
    end

    if has_visited_children(node, acc) do
      if node.is_root do
        IO.inspect(acc)
        IO.inspect("I am done")
        acc
      else
        {parent, new_visited} = getLastNode(visited)
        depth_search(parent, new_visited, acc)
      end
    end
  end

  def getLastNode(visited) do
    visited
    |> List.pop_at(0)
  end

  def has_visited_children(node, acc) do
    has_visited_left_child(node, acc) and has_visited_right_child(node, acc)
  end

  def has_visited_left_child(node, acc) do
    Enum.any?(acc, fn n -> n == node.left_child.val end)
  end

  def has_visited_right_child(node, acc) do
    Enum.any?(acc, fn n -> n == node.right_child.val end)
  end

  def is_leaf(node) do
    # IO.inspect(node)
    node.left_child == nil and node.right_child == nil
  end
end

TraverseTree.run(tree)
```

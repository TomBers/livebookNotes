# Agents and Tasks

## Why?

The motivation around Tasks and Agents (and more generally the Elixir language) is to make concurrency easier.\
Allowing multiple bits of code to be run at the same time without having to wait for each one to end before the next one gets processed.

Lets start by running a simulated long running job and running it sequentially.

```elixir
# Lets create a new LongRunning code to allow us to do some calculation
defmodule LongRunningCode do
  def run(n, print \\ false) do
    # Just pause for 1/2 second
    :timer.sleep(500)

    if print do
      IO.inspect("#{n} DONE")
    end

    n
  end
end
```

```elixir
# Lets run this sequentially 5 times (should take 5 * 0.5 - 2.5 secs)

1..5
|> Enum.map(fn x -> LongRunningCode.run(x, true) end)
```

If you run that code you can see it takes quite a while.  Lets see how we can improve this (without making the delay shorter)

## Tasks

The Task module is a simple way to run code co-currently.  There a number of ways in Elixir to do this, that allow you to customise a numer of things, but Task offers a simple out of the box approach.

You can check out the [docs](https://hexdocs.pm/elixir/1.12/Task.html)

We will cover 2 ways of using the Task module - start / start_link, and async / await

Because the difference in start and start_link involves supervision, I will start with async / await

(From the docs)

> Tasks are processes meant to execute one particular action throughout their lifetime, often with little or no communication with other processes.

### Async / await example

We are going to create a task for each LongRunningCode call.  This does a little magic.  It starts up a new process (you can think of it as a new computer) and can do any computation you want in Elixir (API calls, Database access, heavy computation etc)
As this is an atomic piece of processing (it isn't relying on other things to finish first) it can be done on any free resource on your computer (you will notice a big speed up on multi-core machines).

```elixir
# We now want to run 5 jobs in and add up the returned values

1..5
# Make a task for each value in the range
|> Enum.map(fn x -> Task.async(fn -> LongRunningCode.run(x) end) end)
# The async returns a refernce to a process, we can then await that process to complete
|> Enum.map(fn task -> Task.await(task) end)
|> IO.inspect()
|> Enum.sum()
```

You should have hopefully seen that the above code returned in about 1/2 second (depending on your system).  Elixir will use the available CPU cores on your machine, in case when you are running on a single core machine (less common nowadays) you might not see the damatic speed increase.

The Async starts a new process and returns a process identifier(PID) that is a way of communicating with this process.

The Await takes this process and gets a result. (You can use Async without waiting for the result)

### start and start_link

You can think of start (and start_link) as being useful when you do not care about the results of the code and what to fire and forget.

> This should only used when the task is used for side-effects (like I/O) and you have no interest on its results nor if it completes successfully.

Note - start requires a function with zero arity function (a function with no arguments) - you can simply wrap the function you want to run in a fn -> end

```elixir
# Lets start with start to begin with

1..5
|> Enum.map(fn x -> Task.start(fn -> LongRunningCode.run(x, true) end) end)
```

```elixir
1..5
|> Enum.map(fn x -> Task.start_link(fn -> LongRunningCode.run(x, true) end) end)
```

### To supervise or not to supervise??

What distinguishes the start from the start link is the response to failure.  If something in your code blows up, do you want it so restart and try again or accept it is not working?

For different use cases different answers are required.  If it is an API that is failing, is it that the entire service is down and you are best leaving it, or is it a vital bit of information that should should not fail?

Lets start by modifying our long running job to randomly fail 50% of the time.

```elixir
defmodule CrashCode do
  def run(n) do
    if do_crash?() do
      :error
    else
      IO.inspect("#{n} DONE")
      n
    end
  end

  defp do_crash? do
    Enum.random([false, true])
  end
end
```

```elixir
1..5
|> Enum.map(fn x -> Task.start(fn -> CrashCode.run(x) end) end)
```

We can see that the above code will run succssfully a random number of times.  If you keep running it, it will print out between 0 and 5 messages each run.

What we would like is to have some way of knowing if the code was successful and restarting the process if if fails.

As supervision is quite a novel topic, it deserves it's own document (To be written)

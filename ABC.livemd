# ABC's of Functional Programming

## Different ways of thinking in FP

The goal of this document is to give a very opinionate view on a way of thinking about functional programming for those coming from a more imperative background be it popular web languages (JS, Python) or C like coding (inc Java).

Hopefully it will provide a useful way of thinking about tackling problems in a FP approach and how some issues become easier (definitely different)

## Immutability

Possibly the first thing that you will hit in FP and will leave you scratching your head is immutability.

There is alot written about this topic and what benefits it can bring.  I want to focus on how it can feel off coming from an Imperative background.

Typically in an imperative approach, each command is executed in order and we can modify or variables.  Each time we modify a variable it gets update to the new value, so for example:

```
count = 0 
for (i = 0; i <= 10; i++) {
  count += i
}
```

At the end of this loop count will have the value 100.  However if we try and do this in Elixir it will not work.

```elixir
count = 0
for n <- 1..10, do: count + n
```

We get a very different looking result. We get a `list` of values, and the key thing to observe is that the count is always 0, we can count on the value of count not changing.

> They simply donâ€™t allow values in a certain memory location to change.

This is very important to running code concurrently see [Immutability in Elixir](https://darioghilardi.com/immutability-in-elixir)

## Recursion

So what if I did actually want to do some sort of counting code (run a code some number of times and get a single result out)?

```elixir

```

## Map



```elixir

```

## Reduce



```elixir

```
